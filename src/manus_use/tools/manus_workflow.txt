"""Custom workflow tool for ManusUse that supports different agent types."""

import logging
from typing import Any, Dict, Optional

from strands_tools.workflow import WorkflowManager, workflow, TOOL_SPEC
from strands.tools import tool

from ..agents import ManusAgent, BrowserUseAgent, DataAnalysisAgent, MCPAgent
from ..config import Config

logger = logging.getLogger(__name__)


class ManusWorkflowManager(WorkflowManager):
    """Extended workflow manager that supports ManusUse agent types."""
    
    def __init__(self, tool_context: Dict[str, Any]):
        super().__init__(tool_context)
        
        # Get config for agent initialization
        self.manus_config = Config.from_file()
        
        # Initialize agent registry
        self.agent_registry = {
            "manus": ManusAgent,
            "browser": BrowserUseAgent,
            "data_analysis": DataAnalysisAgent,
            "mcp": MCPAgent,
        }
        
        # Cache for agent instances
        self.agent_cache = {}
    
    def get_agent_for_task(self, task: Dict) -> Any:
        """Get the appropriate agent instance for a task based on agent_type."""
        agent_type = task.get("agent_type", "manus")
        
        # Check cache first
        if agent_type in self.agent_cache:
            return self.agent_cache[agent_type]
        
        # Get agent class from registry
        agent_class = self.agent_registry.get(agent_type)
        if not agent_class:
            logger.warning(f"Unknown agent type: {agent_type}, falling back to ManusAgent")
            agent_class = ManusAgent
        
        # Create agent instance
        try:
            if agent_type == "browser":
                # BrowserUseAgent might need special initialization
                agent = agent_class(config=self.manus_config)
            else:
                # Other agents use standard initialization
                agent = agent_class(
                    model=self.manus_config.get_model(),
                    config=self.manus_config
                )
            
            # Cache the agent
            self.agent_cache[agent_type] = agent
            return agent
            
        except Exception as e:
            logger.error(f"Error creating {agent_type} agent: {str(e)}")
            # Fall back to base agent
            return self.base_agent
    
    def execute_task(self, task: Dict, workflow: Dict, tool_use_id: str) -> Dict:
        """Execute a single task using the appropriate agent type."""
        try:
            # Build context from dependent tasks
            context = []
            if task.get("dependencies"):
                for dep_id in task["dependencies"]:
                    dep_result = workflow["task_results"].get(dep_id, {})
                    if dep_result.get("status") == "completed" and dep_result.get("result"):
                        # Format the dependency results
                        dep_content = [msg.get("text", "") for msg in dep_result["result"]]
                        context.append(f"Results from {dep_id}:\n" + "\n".join(dep_content))

            # Build comprehensive task prompt with context
            task_prompt = task["description"]
            if context:
                task_prompt = "Previous task results:\n" + "\n\n".join(context) + "\n\nTask:\n" + task_prompt

            # Get the appropriate agent for this task
            agent = self.get_agent_for_task(task)
            
            # Get task-specific overrides if provided
            task_kwargs = {}
            if task.get("system_prompt"):
                # For agents that support system_prompt override
                if hasattr(agent, 'system_prompt'):
                    original_prompt = agent.system_prompt
                    agent.system_prompt = task["system_prompt"]

            # Execute task using the appropriate agent
            result = agent(task_prompt, **task_kwargs)
            
            # Restore original system prompt if changed
            if task.get("system_prompt") and hasattr(agent, 'system_prompt') and 'original_prompt' in locals():
                agent.system_prompt = original_prompt

            # Extract response content - handle both dict and custom object return types
            try:
                # If result is a dict or has .get() method
                content = result.get("content", [])
            except AttributeError:
                # If result is an object with .content attribute
                content = getattr(result, "content", [])
                # For string results (like from BrowserUseAgent)
                if isinstance(result, str):
                    content = [{"text": result}]

            # Extract stop_reason - handle both dict and custom object return types
            try:
                # If result is a dict or has .get() method
                stop_reason = result.get("stop_reason", "")
            except AttributeError:
                # If result is an object with .stop_reason attribute
                stop_reason = getattr(result, "stop_reason", "")

            # Update task status
            status = "success" if stop_reason != "error" else "error"
            return {
                "toolUseId": tool_use_id,
                "status": status,
                "content": content,
            }

        except Exception as e:
            error_msg = f"Error executing task {task['task_id']}: {str(e)}"
            logger.error(f"\nError: {error_msg}")
            return {"status": "error", "content": [{"text": error_msg}]}


# Create a custom tool spec that uses our extended workflow manager
MANUS_TOOL_SPEC = TOOL_SPEC.copy()
MANUS_TOOL_SPEC["name"] = "manus_workflow"
MANUS_TOOL_SPEC["description"] = TOOL_SPEC["description"] + "\n\nExtended to support ManusUse agent types: manus, browser, data_analysis, mcp."


#@tool
def manus_workflow(tool: Dict[str, Any], **kwargs: Any) -> Dict[str, Any]:
    """ManusUse workflow tool that supports different agent types."""
    import uuid
    from strands.types.tools import ToolResult
    
    system_prompt = kwargs.get("system_prompt")
    inference_config = kwargs.get("inference_config")
    messages = kwargs.get("messages")
    tool_config = kwargs.get("tool_config")

    try:
        tool_use_id = tool.get("toolUseId", str(uuid.uuid4()))
        tool_input = tool.get("input", {})
        action = tool_input.get("action")

        # Initialize our custom workflow manager
        manager = ManusWorkflowManager(
            {
                "system_prompt": system_prompt,
                "inference_config": inference_config,
                "messages": messages,
                "tool_config": tool_config,
            }
        )

        if action == "create":
            workflow_id = tool_input.get("workflow_id", str(uuid.uuid4()))
            if not tool_input.get("tasks"):
                return {
                    "toolUseId": tool_use_id,
                    "status": "error",
                    "content": [{"text": "Tasks are required for create action"}],
                }

            result = manager.create_workflow(workflow_id, tool_input["tasks"], tool_use_id)

        elif action == "start":
            if not tool_input.get("workflow_id"):
                return {
                    "toolUseId": tool_use_id,
                    "status": "error",
                    "content": [{"text": "workflow_id is required for start action"}],
                }

            result = manager.start_workflow(tool_input["workflow_id"], tool_use_id)

        elif action == "list":
            result = manager.list_workflows(tool_use_id)

        elif action == "status":
            if not tool_input.get("workflow_id"):
                return {
                    "toolUseId": tool_use_id,
                    "status": "error",
                    "content": [{"text": "workflow_id is required for status action"}],
                }

            result = manager.get_workflow_status(tool_input["workflow_id"], tool_use_id)

        elif action == "delete":
            if not tool_input.get("workflow_id"):
                return {
                    "toolUseId": tool_use_id,
                    "status": "error",
                    "content": [{"text": "workflow_id is required for delete action"}],
                }

            result = manager.delete_workflow(tool_input["workflow_id"], tool_use_id)

        else:
            return {
                "toolUseId": tool_use_id,
                "status": "error",
                "content": [{"text": f"Unknown action: {action}"}],
            }

        return {
            "toolUseId": tool_use_id,
            "status": result["status"],
            "content": result["content"],
        }

    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        error_msg = f"Error: {str(e)}\n\nTraceback:\n{error_trace}"
        logger.error(f"\nError in manus_workflow tool: {error_msg}")
        return {
            "toolUseId": tool_use_id,
            "status": "error",
            "content": [{"text": error_msg}],
        }