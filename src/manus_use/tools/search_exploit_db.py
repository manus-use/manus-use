#!/usr/bin/env python3
"""
Custom tool for searching the Exploit-DB database for exploits.
This module follows the Strands SDK's module-based tool specification.
"""

import requests
import json
from typing import Dict, Any, List
from strands.types.tools import ToolResult, ToolUse

TOOL_SPEC = {
    "name": "search_exploit_db",
    "description": (
        "Searches the Exploit-DB database for public exploits related to a given CVE ID or general keyword. "
        "This is a critical tool for assessing the real-world risk and availability of exploits for a vulnerability."
    ),
    "inputSchema": {
        "json": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "The CVE ID (e.g., 'CVE-2024-3094') or general keyword to search for exploits.",
                }
            },
            "required": ["query"],
        }
    },
}

def search_exploit_db(tool: ToolUse, **kwargs: Any) -> ToolResult:
    tool_use_id = tool["toolUseId"]
    tool_input = tool["input"]
    query = tool_input.get("query")

    if not isinstance(query, str) or not query.strip():
        return {
            "toolUseId": tool_use_id,
            "status": "error",
            "content": [{"text": "Invalid query. Must be a non-empty string."}]
        }

    base_url = "https://www.exploit-db.com/search"
    # Exploit-DB uses a simple GET parameter for search
    url = f"{base_url}?q={requests.utils.quote(query)}"

    try:
        response = requests.get(url, timeout=15)
        response.raise_for_status()  # Raise an exception for bad status codes

        html_content = response.text
        results: List[Dict[str, Any]] = []

        # Basic parsing: Look for table rows that contain exploit links
        # This is a very fragile method and depends heavily on Exploit-DB's HTML structure.
        # A more robust solution would use BeautifulSoup.
        exploit_entries = html_content.split('<tr class="stripe" data-row-id=')
        
        for entry in exploit_entries[1:]: # Skip the first split which is before the first <tr>
            title_start = entry.find('<a href="/exploits/')
            if title_start == -1: continue
            title_end = entry.find('</a>', title_start)
            if title_end == -1: continue
            
            link_start = entry.find('href="', title_start) + len('href="')
            link_end = entry.find('"', link_start)

            title = entry[title_start:title_end].split('>')[-1].strip()
            link = "https://www.exploit-db.com" + entry[link_start:link_end].strip()
            
            # Extract type (e.g., webapps, local, remote)
            type_start = entry.find('<a href="/exploits/tags/')
            exploit_type = "N/A"
            if type_start != -1:
                type_start = entry.find('>', type_start) + 1
                type_end = entry.find('</a>', type_start)
                if type_end != -1:
                    exploit_type = entry[type_start:type_end].strip()

            results.append({
                "title": title,
                "link": link,
                "type": exploit_type
            })
            
            if len(results) >= 5: # Limit to top 5 results for brevity
                break

        if not results:
            return {
                "toolUseId": tool_use_id,
                "status": "success",
                "content": [{"json": {"summary": f"No exploits found on Exploit-DB for '{query}'.", "exploits": []}}]
            }

        summary = f"Found {len(results)} potential exploits on Exploit-DB for '{query}'."
        return {
            "toolUseId": tool_use_id,
            "status": "success",
            "content": [{"json": {"summary": summary, "exploits": results}}]
        }

    except requests.exceptions.RequestException as e:
        return {"toolUseId": tool_use_id, "status": "error", "content": [{"text": f"Request to Exploit-DB failed: {e}"}]}
    except Exception as e:
        return {"toolUseId": tool_use_id, "status": "error", "content": [{"text": f"An unexpected error occurred during Exploit-DB search: {e}"}]}