#!/usr/bin/env python3
"""
Tool for verifying exploit PoCs in an isolated Docker environment.

Builds a vulnerable target from an LLM-generated Dockerfile, executes the
exploit code against it on an internal network, and returns verification results.
"""

import time
from typing import Any

from strands.types.tools import ToolResult, ToolUse

from manus_use.sandbox.exploit_sandbox import ExploitSandbox

TOOL_SPEC = {
    "name": "verify_exploit",
    "description": (
        "Verifies a Proof-of-Concept exploit by building a vulnerable Docker environment "
        "from a provided Dockerfile, executing the exploit code against it in an isolated "
        "network, and returning the verification results including stdout, stderr, and "
        "target logs. Use this after identifying a functional PoC to confirm exploitability."
    ),
    "inputSchema": {
        "json": {
            "type": "object",
            "properties": {
                "dockerfile_content": {
                    "type": "string",
                    "description": (
                        "Complete Dockerfile content that sets up the vulnerable target "
                        "environment. Should install the vulnerable software version and "
                        "expose the relevant service port."
                    ),
                },
                "exploit_code": {
                    "type": "string",
                    "description": "The PoC exploit code to execute against the target.",
                },
                "exploit_language": {
                    "type": "string",
                    "description": "Language of the exploit code: 'python', 'bash', or 'sh'.",
                },
                "cve_id": {
                    "type": "string",
                    "description": "CVE identifier for logging (e.g., 'CVE-2024-3094').",
                },
                "target_info": {
                    "type": "object",
                    "description": "Information about the vulnerability target.",
                    "properties": {
                        "affected_software": {
                            "type": "string",
                            "description": "Name of the affected software.",
                        },
                        "affected_versions": {
                            "type": "string",
                            "description": "Affected version range.",
                        },
                        "vulnerability_type": {
                            "type": "string",
                            "description": "Type of vulnerability (e.g., RCE, SQLi, XSS).",
                        },
                    },
                    "required": ["affected_software", "affected_versions", "vulnerability_type"],
                },
                "target_port": {
                    "type": "integer",
                    "description": "Port the target service listens on. Default: 80.",
                },
                "timeout": {
                    "type": "integer",
                    "description": "Exploit execution timeout in seconds. Default: 300.",
                },
            },
            "required": [
                "dockerfile_content",
                "exploit_code",
                "exploit_language",
                "cve_id",
                "target_info",
            ],
        }
    },
}


def verify_exploit(tool: ToolUse, **kwargs: Any) -> ToolResult:
    tool_use_id = tool["toolUseId"]
    inp = tool["input"]

    dockerfile_content = inp.get("dockerfile_content", "")
    exploit_code = inp.get("exploit_code", "")
    exploit_language = inp.get("exploit_language", "python")
    cve_id = inp.get("cve_id", "UNKNOWN")
    target_info = inp.get("target_info", {})
    target_port = inp.get("target_port", 80)
    timeout = inp.get("timeout", 300)

    if not dockerfile_content or not exploit_code:
        return {
            "toolUseId": tool_use_id,
            "status": "error",
            "content": [{"text": "Both dockerfile_content and exploit_code are required."}],
        }

    sandbox = ExploitSandbox(timeout=timeout)
    start_time = time.time()

    try:
        # 1. Build target image
        print(f"[verify_exploit] Building target image for {cve_id}...")
        try:
            image_id = sandbox.build_target(dockerfile_content)
        except Exception as e:
            elapsed = time.time() - start_time
            return _result(tool_use_id, "build_error", str(e), sandbox.build_log, elapsed)

        # 2. Start target container
        print(f"[verify_exploit] Starting target container...")
        try:
            sandbox.start_target(image_id)
        except Exception as e:
            elapsed = time.time() - start_time
            return _result(tool_use_id, "target_error", str(e), sandbox.build_log, elapsed)

        # 3. Wait for target service
        print(f"[verify_exploit] Waiting for target on port {target_port}...")
        ready = sandbox.wait_for_target(port=target_port, timeout=60)
        if not ready:
            elapsed = time.time() - start_time
            target_logs = sandbox.get_target_logs()
            return _result(
                tool_use_id,
                "target_error",
                f"Target service did not become ready on port {target_port} within 60s",
                sandbox.build_log,
                elapsed,
                target_logs=target_logs,
            )

        # 4. Run exploit
        print(f"[verify_exploit] Running exploit code ({exploit_language})...")
        env = {"TARGET_PORT": str(target_port)}
        exploit_result = sandbox.run_exploit(
            code=exploit_code,
            language=exploit_language,
            env=env,
        )

        target_logs = sandbox.get_target_logs()
        elapsed = time.time() - start_time

        # 5. Determine status
        exit_code = exploit_result.get("exit_code", -1)
        if exit_code == 0:
            status = "verified"
            summary = (
                f"Exploit for {cve_id} targeting {target_info.get('affected_software', 'unknown')} "
                f"({target_info.get('vulnerability_type', 'unknown')}) executed successfully "
                f"(exit code 0) in {elapsed:.1f}s. The PoC appears to be functional against "
                f"the vulnerable environment."
            )
        else:
            status = "failed"
            summary = (
                f"Exploit for {cve_id} targeting {target_info.get('affected_software', 'unknown')} "
                f"exited with code {exit_code} after {elapsed:.1f}s. The PoC did not "
                f"succeed against the test environment."
            )

        return {
            "toolUseId": tool_use_id,
            "status": "success",
            "content": [{
                "json": {
                    "verification_status": status,
                    "summary": summary,
                    "exploit_output": exploit_result,
                    "target_logs": target_logs,
                    "build_log": sandbox.build_log,
                    "execution_time_seconds": round(elapsed, 2),
                }
            }],
        }

    except Exception as e:
        elapsed = time.time() - start_time
        return {
            "toolUseId": tool_use_id,
            "status": "error",
            "content": [{"text": f"Unexpected error during exploit verification: {e}"}],
        }
    finally:
        print(f"[verify_exploit] Cleaning up...")
        sandbox.cleanup()


def _result(
    tool_use_id: str,
    status: str,
    error_msg: str,
    build_log: str,
    elapsed: float,
    target_logs: str = "",
) -> ToolResult:
    """Helper to build an error-state result."""
    summary = f"Verification {status}: {error_msg}"
    return {
        "toolUseId": tool_use_id,
        "status": "success",
        "content": [{
            "json": {
                "verification_status": status,
                "summary": summary,
                "exploit_output": {"stdout": "", "stderr": "", "exit_code": -1},
                "target_logs": target_logs,
                "build_log": build_log,
                "execution_time_seconds": round(elapsed, 2),
            }
        }],
    }
