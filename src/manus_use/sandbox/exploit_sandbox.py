"""Exploit verification sandbox using a two-container Docker setup.

Builds a vulnerable target from an LLM-generated Dockerfile, then runs
exploit code against it on an isolated internal network.
"""

import io
import tarfile
import tempfile
import time
import uuid
from pathlib import Path
from typing import Dict, Optional

import docker
from docker.errors import ContainerError, ImageNotFound, NotFound


class ExploitSandbox:
    """Manages the lifecycle of a two-container exploit verification environment."""

    def __init__(
        self,
        timeout: int = 300,
        memory_limit: str = "512m",
        cpu_limit: float = 1.0,
    ):
        self.timeout = timeout
        self.memory_limit = memory_limit
        self.cpu_limit = cpu_limit

        self._uid = uuid.uuid4().hex[:8]
        self.client: Optional[docker.DockerClient] = None
        self.network = None
        self.target_container = None
        self.exploit_container = None
        self.image_id: Optional[str] = None
        self.build_log: str = ""

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def build_target(self, dockerfile_content: str) -> str:
        """Build a Docker image from the supplied Dockerfile string.

        Returns the image id.
        """
        self.client = docker.from_env()

        with tempfile.TemporaryDirectory() as tmpdir:
            dockerfile_path = Path(tmpdir) / "Dockerfile"
            dockerfile_path.write_text(dockerfile_content)

            image, logs = self.client.images.build(
                path=tmpdir,
                rm=True,
                forcerm=True,
                timeout=300,
            )
            self.build_log = "\n".join(
                line.get("stream", "").rstrip()
                for line in logs
                if line.get("stream")
            )

        self.image_id = image.id
        return image.id

    def start_target(self, image_id: str) -> None:
        """Create an internal bridge network and start the target container."""
        network_name = f"exploit-net-{self._uid}"
        self.network = self.client.networks.create(
            name=network_name,
            driver="bridge",
            internal=True,
        )

        self.target_container = self.client.containers.run(
            image_id,
            name=f"exploit-target-{self._uid}",
            detach=True,
            mem_limit=self.memory_limit,
            cpu_quota=int(self.cpu_limit * 100000),
            cpu_period=100000,
            network=self.network.name,
        )

        # Assign a predictable alias so the exploit container can reach it
        self.network.disconnect(self.target_container)
        self.network.connect(self.target_container, aliases=["target"])

    def wait_for_target(self, port: int, timeout: int = 60) -> bool:
        """Poll the target container until the service port is listening."""
        # Use a throwaway container on the same network to probe the port
        deadline = time.time() + timeout
        while time.time() < deadline:
            try:
                result = self.client.containers.run(
                    "python:3.12-slim",
                    command=(
                        "python -c \"import socket,sys; "
                        f"s=socket.socket(); s.settimeout(2); "
                        f"s.connect(('target',{port})); s.close(); "
                        "sys.exit(0)\""
                    ),
                    network=self.network.name,
                    mem_limit="64m",
                    remove=True,
                )
                return True
            except ContainerError:
                time.sleep(2)
            except Exception:
                time.sleep(2)
        return False

    def run_exploit(
        self,
        code: str,
        language: str = "python",
        env: Optional[Dict[str, str]] = None,
    ) -> Dict:
        """Start an exploit container on the same network and execute *code*."""
        ext = _file_extension(language)
        cmd = _execution_command(language, f"/tmp/exploit.{ext}")

        environment = {"TARGET_HOST": "target"}
        if env:
            environment.update(env)

        self.exploit_container = self.client.containers.run(
            "python:3.12-slim",
            name=f"exploit-runner-{self._uid}",
            command="sleep infinity",
            detach=True,
            mem_limit=self.memory_limit,
            cpu_quota=int(self.cpu_limit * 100000),
            cpu_period=100000,
            network=self.network.name,
            environment=environment,
        )

        # Copy exploit code into the container
        _copy_to_container(
            self.exploit_container,
            code.encode(),
            f"/tmp/exploit.{ext}",
        )

        # Execute
        exec_result = self.exploit_container.exec_run(
            cmd,
            stdout=True,
            stderr=True,
            demux=True,
            environment=environment,
        )

        stdout = (exec_result.output[0] or b"").decode("utf-8", errors="replace")
        stderr = (exec_result.output[1] or b"").decode("utf-8", errors="replace")

        return {
            "stdout": stdout,
            "stderr": stderr,
            "exit_code": exec_result.exit_code,
        }

    def get_target_logs(self) -> str:
        """Return stdout/stderr logs from the target container."""
        if self.target_container:
            try:
                return self.target_container.logs().decode("utf-8", errors="replace")
            except Exception:
                return ""
        return ""

    def cleanup(self) -> None:
        """Remove containers, network, and built image."""
        for ctr in (self.exploit_container, self.target_container):
            if ctr is not None:
                try:
                    ctr.kill()
                except Exception:
                    pass
                try:
                    ctr.remove(force=True)
                except Exception:
                    pass

        if self.network is not None:
            try:
                self.network.remove()
            except Exception:
                pass

        if self.image_id is not None and self.client is not None:
            try:
                self.client.images.remove(self.image_id, force=True)
            except Exception:
                pass

        self.target_container = None
        self.exploit_container = None
        self.network = None
        self.image_id = None


# ------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------

def _copy_to_container(container, data: bytes, container_path: str) -> None:
    """Copy bytes into a running container using put_archive."""
    tar_stream = io.BytesIO()
    with tarfile.TarFile(fileobj=tar_stream, mode="w") as tar:
        info = tarfile.TarInfo(name=Path(container_path).name)
        info.size = len(data)
        info.mode = 0o755
        tar.addfile(info, io.BytesIO(data))

    container.put_archive(str(Path(container_path).parent), tar_stream.getvalue())


def _file_extension(language: str) -> str:
    return {"python": "py", "bash": "sh", "sh": "sh"}.get(language.lower(), "sh")


def _execution_command(language: str, file_path: str) -> str:
    return {
        "python": f"python {file_path}",
        "bash": f"bash {file_path}",
        "sh": f"sh {file_path}",
    }.get(language.lower(), f"sh {file_path}")
